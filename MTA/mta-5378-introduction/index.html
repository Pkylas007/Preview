<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="chrometwo"><head><title>Configuring and Using Developer Lightspeed for MTA</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css"/><meta name="generator" content="publican v4.3.2"/><meta name="description" content="By using Developer Lightspeed for Migration Toolkit for Applications (MTA), you can modernize applications in your organization by applying LLM-driven code changes to resolve issues found through static code analysis. You can automate code fixes, review the suggested changes, and apply all code changes at once with minimum manual effort."/><link rel="next" href="#intro-to-the-developer-lightspeed_mta-developer-lightspeed" title="Chapter 1. Introduction to the Developer Lightspeed for MTA"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><script type="text/javascript" src="Common_Content/scripts/jquery-1.7.1.min.js"> </script><script type="text/javascript" src="Common_Content/scripts/utils.js"> </script><script type="text/javascript" src="Common_Content/scripts/highlight.js/highlight.pack.js"> </script></head><body><div id="chrometwo"><div id="main"><div xml:lang="en-US" class="book" id="idm45178984326224"><div class="titlepage"><div><div class="producttitle"><span class="productname">Migration Toolkit for Applications</span> <span class="productnumber">8.0</span></div><div><h1 class="title">Configuring and Using Developer Lightspeed for MTA</h1></div><div><h2 class="subtitle">Using the Migration Toolkit for Applications Developer Lightspeed to modernize your applications</h2></div><div><div xml:lang="en-US" class="authorgroup"><span class="orgname">Red Hat Customer Content Services</span></div></div><div><a href="#idm45178973884480">Legal Notice</a></div><div><div class="abstract"><p class="title"><strong>Abstract</strong></p><div class="para">
				By using Developer Lightspeed for Migration Toolkit for Applications (MTA), you can modernize applications in your organization by applying LLM-driven code changes to resolve issues found through static code analysis. You can automate code fixes, review the suggested changes, and apply all code changes at once with minimum manual effort.
			</div></div></div></div><hr/></div><div class="toc"><ul class="toc"><li><span class="chapter"><a href="#intro-to-the-developer-lightspeed_mta-developer-lightspeed">1. Introduction to the Developer Lightspeed for MTA</a></span><ul><li><span class="section"><a href="#use-case-ai-code-fix_mta-developer-lightspeed">1.1. Use case for AI-driven code fixes</a></span></li><li><span class="section"><a href="#how-developerlightspped-works_mta-developer-lightspeed">1.2. How does Developer Lightspeed for MTA work</a></span></li><li><span class="section"><a href="#modes-developer-lightspeed_mta-developer-lightspeed">1.3. Modes in Developer Lightspeed for MTA</a></span></li><li><span class="section"><a href="#benefits-using-developer-lightspeed_mta-developer-lightspeed">1.4. Benefits of using Developer Lightspeed for MTA</a></span></li></ul></li></ul></div><section class="chapter" id="intro-to-the-developer-lightspeed_mta-developer-lightspeed"><div class="titlepage"><div><div><h1 class="title">Chapter 1. Introduction to the Developer Lightspeed for MTA</h1></div></div></div><p>
			Starting from 8.0.0, Migration Toolkit for Applications (MTA) integrates with large language models (LLM) through the Red Hat Developer Lightspeed for migration toolkit for applications component in the Visual Studio (VS) Code extension. You can use Developer Lightspeed for MTA to apply LLM-driven code changes to resolve issues found through static code analysis of Java applications.
		</p><section class="section" id="use-case-ai-code-fix_mta-developer-lightspeed"><div class="titlepage"><div><div><h2 class="title">1.1. Use case for AI-driven code fixes</h2></div></div></div><p>
				MTA performs the static code analysis for a specified target technology to which you want to migrate your applications. Red Hat provides 2400+ analysis rules in MTA for various Java technologies and you can extend the ruleset for custom frameworks or new technologies by creating custom rules.
			</p><p>
				The static code analysis identifies issues in your code that must be resolved. When working with a large portfolio of applications, the issue descriptions and rule definitions generate a large corpus of repetitive problem statements and solutions. As a result, migrators often duplicate work by resolving the same issues across multiple applications and migration waves.
			</p><p>
				Migrators do duplicate work by resolving issues that are repeated across applications in different migration waves.
			</p></section><section class="section" id="how-developerlightspped-works_mta-developer-lightspeed"><div class="titlepage"><div><div><h2 class="title">1.2. How does Developer Lightspeed for MTA work</h2></div></div></div><p>
				Developer Lightspeed for MTA works by collecting and storing code changes across many applications, generating context to create prompts for the LLM of your choice, and producing migration hints from the LLM to resolve specific issues.
			</p><p>
				The LLM generates migration hints based on the context shared by the {mt-dl-plugin}. The context allows the LLM to "reason" and generate the hints. This implementation helps to overcome the limited context size that prevents LLMs from analyzing the source code of an entire application and knowledge gap which often lack organization-specific details because they are not trained on that data.
			</p><p>
				The context is a combination of the following inputs that are shared with the LLM:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Description of issues detected by MTA when you run a static code analysis for a given set of target technologies.
					</li><li class="listitem">
						(Optional) Extra information that you include in the rules. The default and custom rules may contain additional information that helps Developer Lightspeed for MTA to define the context.
					</li><li class="listitem"><p class="simpara">
						When you enable the Solution Server, a solved example is created when a Migrator accepts a resolution in a previous analysis that results in updated code or an unfamiliar issue in a legacy application that the Migrator manually fixed. Solved examples are stored in the Solution Server.
					</p><p class="simpara">
						More instances of solved examples for an issue enhance the context and improves the success metrics of rules that trigger the issue. A higher success metrics of an issue refers to the higher confidence level associated with the accepted resolutions for that issue in previous analyses.
					</p></li><li class="listitem"><p class="simpara">
						(Optional) If you enable the solution server mode, the Solution Server extracts a pattern of solution that can be used by the LLM to generate a more accurate migration hint.
					</p><p class="simpara">
						The improvement in the quality of migration hints results in more accurate code resolutions. In turn, these updated code is stored in the solution server to generate a better migration hint in future.
					</p><p class="simpara">
						This cyclical improvement of resolution pattern from the solution server and improved migration hints lead to more reliable code changes as you migrate applications in different migration waves
					</p></li></ul></div><p>
				The Solution Server acts as institutional memory capturing code changes from previous migrations. This helps you to leverage the recurring patterns of solutions for issues that are repeated in many applications.
			</p><p>
				Thus, when you deploy Developer Lightspeed for MTA for analyzing your entire application portfolio, it enables you to be consistent with the common fixes you need to make in the source code of any Java application.
			</p><p>
				It also enables you to control the analysis through manual reviews of the suggested AI resolutions by accepting or rejecting the changes while reducing the overall time and effort required to prepare your application for migration.
			</p></section><section class="section" id="modes-developer-lightspeed_mta-developer-lightspeed"><div class="titlepage"><div><div><h2 class="title">1.3. Modes in Developer Lightspeed for MTA</h2></div></div></div><p>
				You can run an analysis for AI-assisted code fixes in two modes: the Agentic AI and the Retrieval Augmented Generation (RAG) solution delivered by the Solution Server.
			</p><p>
				If you enable the agentic AI mode, Developer Lightspeed for MTA streams an automated analysis of the code in a loop until all issues are resolved and changes the code with the updates. In the initial run, the AI agent:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Plans the context to define the issues.
					</li><li class="listitem">
						Chooses a suitable sub agent for the analysis task. Works with the LLM to generate fix suggestions. The reasoning transcript and files to be changed are displayed to the user.
					</li><li class="listitem">
						Applies the changes to the code once the user approves the updates.
					</li></ul></div><p>
				If you accept that the agentic AI must continue to make changes, it compiles the code and runs a partial analysis. In this phase, the agentic AI can detect diagnostic issues (if any) generated by tools that you installed in the VS Code IDE. You can accept the agentic AI’s suggestion to address these diagnostic issues too. After every phase of applying changes to the code, the agentic AI runs another round of automated analysis depending on your acceptance, until it has run through all the files in your project and resolved the issues in the code.
			</p><p>
				Agentic AI generates a new file in each round when it applies the suggestions in the code. The time taken by the agentic AI to complete several rounds of analysis depends on the size of the application, the number of issues, and the complexity of the code.
			</p><p>
				When you use the Solution Server mode, Developer Lightspeed for MTA delivers a solution for an issue that is based on solved examples or code changes in past analysis. When you fix code, you can view a diff of the updated portions of the code and the original source code to do a manual review. In such an analysis, the user has more control over the changes that must be applied to the code.
			</p></section><section class="section" id="benefits-using-developer-lightspeed_mta-developer-lightspeed"><div class="titlepage"><div><div><h2 class="title">1.4. Benefits of using Developer Lightspeed for MTA</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						<span class="strong strong"><strong>Model agnostic</strong></span> - Developer Lightspeed for MTA follows a "Bring Your Own Model" approach, allowing your organization to use a preferred LLM.
					</li><li class="listitem">
						<span class="strong strong"><strong>Iterative refinement</strong></span> - Developer Lightspeed for MTA can include an agent that iterates through the source code to run a series of automated analyses that resolves both the code base and diagnostic issues.
					</li><li class="listitem">
						<span class="strong strong"><strong>Contextual code generation</strong></span> - By leveraging AI for static code analysis, Developer Lightspeed for MTA breaks down complex problems into more manageable ones, providing the LLM with focused context to generate meaningful results. This helps overcome the limited context size of LLMs when dealing with large codebases.
					</li><li class="listitem">
						<span class="strong strong"><strong>No fine tuning</strong></span> - You also do not need to fine tune your model with a suitable data set for analysis which leaves you free to use and switch LLM models to respond to your requirements.
					</li><li class="listitem">
						<span class="strong strong"><strong>Learning and Improvement</strong></span> - As more parts of a codebase are migrated with Developer Lightspeed for MTA, it can use RAG to learn from the available data and provide better recommendations in subsequent application analysis.
					</li></ul></div></section></section><div><div xml:lang="en-US" class="legalnotice" id="idm45178973884480"><h1 class="legalnotice">Legal Notice</h1><div class="para">
		Copyright <span class="trademark"/>© 2025 Red Hat, Inc.
	</div><div class="para">
		The text of and illustrations in this document are licensed by Red Hat under a Creative Commons Attribution–Share Alike 3.0 Unported license ("CC-BY-SA"). An explanation of CC-BY-SA is available at <a class="uri" href="http://creativecommons.org/licenses/by-sa/3.0/">http://creativecommons.org/licenses/by-sa/3.0/</a>. In accordance with CC-BY-SA, if you distribute this document or an adaptation of it, you must provide the URL for the original version.
	</div><div class="para">
		Red Hat, as the licensor of this document, waives the right to enforce, and agrees not to assert, Section 4d of CC-BY-SA to the fullest extent permitted by applicable law.
	</div><div class="para">
		Red Hat, Red Hat Enterprise Linux, the Shadowman logo, the Red Hat logo, JBoss, OpenShift, Fedora, the Infinity logo, and RHCE are trademarks of Red Hat, Inc., registered in the United States and other countries.
	</div><div class="para">
		<span class="trademark">Linux</span>® is the registered trademark of Linus Torvalds in the United States and other countries.
	</div><div class="para">
		<span class="trademark">Java</span>® is a registered trademark of Oracle and/or its affiliates.
	</div><div class="para">
		<span class="trademark">XFS</span>® is a trademark of Silicon Graphics International Corp. or its subsidiaries in the United States and/or other countries.
	</div><div class="para">
		<span class="trademark">MySQL</span>® is a registered trademark of MySQL AB in the United States, the European Union and other countries.
	</div><div class="para">
		<span class="trademark">Node.js</span>® is an official trademark of Joyent. Red Hat is not formally related to or endorsed by the official Joyent Node.js open source or commercial project.
	</div><div class="para">
		The <span class="trademark">OpenStack</span>® Word Mark and OpenStack logo are either registered trademarks/service marks or trademarks/service marks of the OpenStack Foundation, in the United States and other countries and are used with the OpenStack Foundation's permission. We are not affiliated with, endorsed or sponsored by the OpenStack Foundation, or the OpenStack community.
	</div><div class="para">
		All other trademarks are the property of their respective owners.
	</div></div></div></div></div></div><script type="text/javascript">
                        jQuery(document).ready(function() {
                            initSwitchery();
                            jQuery('pre[class*="language-"]').each(function(i, block){hljs.highlightBlock(block);});
                        });
                    </script></body></html>